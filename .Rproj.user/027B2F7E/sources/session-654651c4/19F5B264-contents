
install.packages("available")
library("available")
available::suggest(" qPCR data and deltaCt method")
# deltaCT

available::available("deltaCT", browse = FALSE)









library(tidyverse)
library("HTqPCR")

data(qPCRraw)

data <- exprs(qPCRraw)
#write.table(data, "data_wide.txt", sep = "\t")

targets <- rownames(data)
data <- as.data.frame(data)
data$Target <- targets 
data_slim <- pivot_longer(data, -Target, names_to = "Sample", values_to = "Ct")
#data_slim_3gr <- mutate(data_slim, Group = ifelse(Sample == "sample1" | Sample == "sample2", "A",
#                                              ifelse(Sample == "sample3" | Sample == "sample4","B", "C")))

data_slim_2gr <- mutate(data_slim, Group = ifelse(Sample == "sample1" | Sample == "sample2"| Sample == "sample3",
                                                  "Condition1", "Condition2"))

Ct <- data_slim_2gr
View(Ct)
####    simpleRQ package   #####

#########   WCZYTYWANIE DANYCH #######

## plik z danymi musi być w .txt, 
## Pierwsza kolumna musi zawierać geny, pozostałe maja mieć wartości Ct

####    design file musi mieć kolumny Sample i Group, nazwy targetów w obu plikach musza być tożsame!!!!
#### muszą to byc pliki txt

library(tidyverse)

prepare_data <- function(Ct.file, design.file,  sep, dec){
  data_wide <- read.csv(Ct.file,
                        header = TRUE,
                        sep = sep,
                        dec = dec)
  
  data_wide_design <- read.csv(design.file,
                               header = TRUE,
                               sep = sep)
  
  colnames(data_wide)[1] <- "Target"
  data_slim <- pivot_longer(data_wide, -Target, names_to = "Sample", values_to = "Ct")
  data_slim[ ,"Group"] <- NA
  
  for (x in 1:nrow(data_wide_design)) {
    index <- which(data_slim$Sample == data_wide_design$Sample[x])
    data_slim$Group[index] <- data_wide_design$Group[x]
  }
  return(data_slim)
}


data_all <- prepare_data("data_wide.txt", "data_wide_design.txt", sep = "\t", dec = ".")






################################################################
library(tidyverse)

read_Ct <- function(path, sep, dec, skip = 0, col.Sample, col.Target, col.Ct, col.Group, add.col.Flag = FALSE, col.Flag){
  data <- read.csv(path,
    header = TRUE,
    sep = sep, dec = dec, skip = skip)
  if (add.col.Flag == FALSE){
  data <- data[ ,c(col.Sample, col.Target, col.Ct, col.Group)]
  colnames(data) <- c("Sample", "Target", "Ct", "Group")
  }
  if (add.col.Flag == TRUE){
    data <- data[ ,c(col.Sample, col.Target, col.Ct, col.Group, col.Flag)]
    colnames(data) <- c("Sample", "Target", "Ct", "Group", "Flag")
  }
  return(data)
}





Ct <- read_Ct(path = "dataMB.txt",
             sep = "\t",
             dec = ".",
             skip = 0,
             add.col.Flag = TRUE,
             col.Sample = 1, col.Target = 2, col.Ct = 5, col.Group = 9, col.Flag = 4)

str(Ct)
summary(Ct)
Ct$Ct

#nazwa kolumny mus pozostac "Flag".
Ct <- mutate(Ct, Flag = ifelse(Flag < 1, "Undetermined", "OK"))



#########   KONTROLA CT - BARPLOT #######

control_Ct_barplot <- function(data, mode, flag.Ct = "Undetermined", maxCt = 35, flag = "Undetermined",
                           col = c("#66c2a5", "#fc8d62"), axis.title.size = 12, axis.text.size = 10,
                           x.axis.title = "", y.axis.title = "Number",
                           legend.title = "Retained for analysis?",
                           plot.title = "", legend.title.size = 12,
                           legend.text.size = 12,
                           legend.position = "top",
                           dpi = 600, width = 15, height = 15,
                           save.to.tiff = FALSE,
                           name.tiff = "Ct_control_barplot"){
  
  data$Ct[data$Ct == flag.Ct] <- 40
  data$Ct <- as.numeric(data$Ct)
  if(sum(colnames(data) %in% "Flag") > 0){
    data <- mutate(data, Detected = ifelse(Ct > maxCt | Flag == flag, yes = "No",  no = "Yes"))
  } else {
  data <- mutate(data, Detected = ifelse(Ct > maxCt , yes = "No",  no = "Yes"))
  }
  if (mode == "Sample"){
  bar <- as.data.frame(table(data$Detected, data$Sample))
  order <- arrange(filter(bar, Var1 == "Yes"), Freq)$Var2
  cat("Returned object contains number of targets retained (Yes) or not retained (No) in samples after filtering.")
  barr <- ggplot(bar, aes(x = reorder(Var2, desc(Freq)), y = Freq, fill = Var1)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    scale_fill_manual(breaks = c("Yes", "No"), values = c("Yes" = col[1],"No" = col[2])) +
    xlab(x.axis.title) + ylab(y.axis.title) +
    labs(fill = legend.title, title = plot.title) +
    theme_classic() + theme(legend.position = legend.position) +
    theme(axis.text = element_text(size = axis.text.size, color = 'black')) +
    theme(axis.title = element_text(size = axis.title.size, color = 'black')) +
    theme(legend.title = element_text(size = legend.title.size, colour="black")) +
    theme(legend.text = element_text(size = legend.text.size, colour="black")) +
    scale_x_discrete(limits = order)
    
  print(barr)
  
    if (save.to.tiff == TRUE){
      ggsave(paste(name.tiff, ".tiff", sep = ""), barr, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
    } else {}
    
    return(table(data$Detected, data$Sample))  

  } else {
    
    bar <- as.data.frame(table(data$Detected, data$Target, data$Group))
    order <- arrange(filter(bar, Var1 == "Yes"), Freq)$Var2
    cat("Returned object contains number of samples retained (Yes) or not retained (No) for each target after filtering.")
    barr <- ggplot(bar, aes(x = reorder(Var2, desc(Freq)), y = Freq, fill = Var1)) +
      geom_bar(stat = "identity") +
      coord_flip() +
      scale_fill_manual(breaks = c("Yes", "No"), values = c("Yes" = col[1],"No" = col[2])) +
      xlab(x.axis.title) + ylab(y.axis.title) +
      labs(fill = legend.title, title = plot.title) +
      theme_classic() + theme(legend.position = legend.position) +
      theme(axis.text = element_text(size = axis.text.size, color = 'black')) +
      theme(axis.title = element_text(size = axis.title.size, color = 'black')) +
      theme(legend.title = element_text(size = legend.title.size, colour="black")) +
      theme(legend.text = element_text(size = legend.text.size, colour="black")) +
      scale_x_discrete(limits = rev(unique(bar$Var2))) +
      facet_wrap(vars(Var3))
    print(barr)
  
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff, ".tiff", sep = ""), barr, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
    return(table(data$Detected, data$Target, data$Group))
    }
}

tar <- control_Ct_barplot(data_all, mode = "Target",
                          flag.Ct = "",
                          maxCt = 35,
                          flag = "",
                          save.to.tiff = TRUE,
                          name.tiff = "Ct_barplot_target")

sam <- control_Ct_barplot(data_all, mode = "Sample",
                          flag.Ct = "Undetermined",
                          maxCt = 35,
                          flag = "Undetermined",
                          save.to.tiff = TRUE,
                          name.tiff = "Ct_barplot_sample")



samples_to_remove <- function(data, fraction = 0.5){
  data <- as.data.frame(data)
  n <- sum(data$Freq[c(1:2)])
  data <- dplyr::filter(data, Var1 == "No" & Freq > n*fraction)
  return(as.vector(data$Var2))
}

samples.to.remove <- samples_to_remove(sam, 0.5)


# dla dwóch grup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
targets_to_remove <- function(data, fraction = 0.5, groups){
  data <- as.data.frame(data)
  data1 <- dplyr::filter(data, Var3 == groups[1])
  data2 <- dplyr::filter(data, Var3 == groups[2])
  n1 <- sum(data1$Freq[c(3:4)])
  n2 <- sum(data2$Freq[c(3:4)])
  data1F <- dplyr::filter(data1, Var1 == "No" & Freq > n1*fraction)
  data2F <- dplyr::filter(data2, Var1 == "No" & Freq > n2*fraction)
  return(unique(c(as.vector(data1F$Var2), as.vector(data2F$Var2))))
}


targets.to.remove <- targets_to_remove(data = tar, fraction = 0.5, groups = c("Condition1", "Condition2"))
#targets.to.remove2 <- targets_to_remove(data = tar, fraction = 0.5, groups = c("A", "C"))





#########   FILTROWANIE DANYCH CT #######

#####   Najlepiej jest przefiltrowac tak aby zostały 2 grupy, trzecią może zostac ale moga zostac braki dnych po imputacji
str(Ct)
filter_Ct <- function(data, flag.Ct = "Undetermined", maxCt, flag = c(""),
                      remove.Target = c(""), remove.Sample = c(""), remove.Group = c("")){
  data <- dplyr::filter(data, Ct != flag.Ct)
  data$Ct <- as.numeric(data$Ct)
  data <- dplyr::filter(data, Ct <= maxCt,
                        !Target %in% remove.Target,
                        !Sample %in% remove.Sample,
                        !Group %in% remove.Group)
  if(sum(colnames(data) %in% "Flag") > 0){
    data <- dplyr::filter(data,
                          !Flag %in% flag)
  }
  return(data)
}




CtF <- filter_Ct(Ct,
                 flag.Ct = "Undetermined",
                 maxCt = 35,
                 remove.Group = c(""),
                 remove.Target = targets.to.remove,
                 remove.Sample = samples.to.remove,
                 flag = "Undetermined")
dim(CtF)
str(CtF)
table(CtF$Target)




#########   Select reference gene        #######
library(tidyverse)

sel_ref <- function(data, candidates, line.width = 1,
                    col,
                    axis.title.size = 12,
                    axis.text.size = 10,
                    x.axis.title = "",
                    y.axis.title = "Ct",
                    legend.title = "",
                    plot.title = "",
                    legend.title.size = 12,
                    legend.text.size = 12,
                    legend.position = "top",
                    dpi = 600, width = 15, height = 15,
                    save.to.tiff = FALSE,
                    name.tiff = "Ct_reference_selection"){
  
  ref <- data %>%
    group_by(Group, Target, Sample) %>%
    summarise(mean = base::mean(Ct, na.rm = TRUE)) %>%
    dplyr::filter(data, Target %in% candidates)
  ref_plot <- ggplot(ref, aes(x = Sample, y = mean, color = Target, group = Target)) +
    geom_line(linewidth = line.width) +
    scale_color_manual(values = c(col)) +
    theme_bw() +
    xlab(x.axis.title) + ylab(y.axis.title) +
    labs(color = legend.title, title = plot.title) +
    theme(legend.position = legend.position) +
    theme(axis.text = element_text(size = axis.text.size, color = 'black')) +
    theme(axis.title = element_text(size = axis.title.size, color = 'black')) +
    theme(legend.title = element_text(size = legend.title.size, colour="black")) +
    theme(legend.text = element_text(size = legend.text.size, colour="black"))
    
  print(ref_plot)
  
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff, ".tiff", sep = ""), ref_plot, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
  ref_var <- group_by(ref, Target)
  ref_var <- summarise(ref_var,
                       min = min(mean),
                       max = max(mean),
                       sd = stats::sd(mean, na.rm = TRUE),
                       var = stats::var(mean, na.rm = TRUE))
  return(as.data.frame(ref_var))
}


sel_ref(CtF, candidates = c("Gene1","Gene10","Gene100"), col = c("#66c2a5", "#fc8d62","red"))




#########   COLLAPSING TECH REPLICATES        #######
# 
# # robimy to zawsze, bo nastepna funkcja chce dane sformatowane przez ta funkcję
# tech_coll <- function(data){
#   data <- group_by(data, Group, Target, Sample)
#   data <- summarise(data, mean = base::mean(Ct, na.rm = FALSE))
#   return(as.data.frame(data))
# }
# 
# 
# CtF_coll <- tech_coll(CtF)
# dim(CtF_coll)
# str(CtF_coll)
# 
# 
# 
# data <- group_by(CtF, Group, Target, Sample)
# data <- summarise(data, mean = base::mean(Ct, na.rm = FALSE))
# str(data)


#########   DELTA CT      #######


# Jeśli są braki danych w kontroli endogennej, to próbki z takimi brakami muszą zostac usunięte z danych,
# chyba że zrobi się imputacje w danch Ct, to wtedy ok.
### UWAGA, jeżeli braki danych dla jakiegoś genu są w całej grupie, to nie ulegną imputacji i zostaną dalej NA

deltaCt <- function(data,
                    imput.by.mean.within.groups = FALSE,
                    ref, save.to.txt = FALSE,
                    name.txt = "dCt_results"){
  data <- data %>%
    group_by(Group, Target, Sample) %>%
    summarise(mean = base::mean(Ct, na.rm = TRUE)) %>%
    as.data.frame()
  if (imput.by.mean.within.groups == TRUE){
  data_wide <- data %>%
    select(Group, Sample, Target, mean) %>%
    pivot_wider(names_from = Target, values_from = mean)
  data_wide_imp <- data_wide %>%
      group_by(Group) %>%
      mutate_if(is.numeric, ~ replace(., is.na(.), mean(., na.rm = TRUE)))
  nas <- sum(is.na(data_wide))
  percentage <- sum(is.na(data_wide))/((ncol(data_wide)-2)*nrow(data_wide))
  dCt <- mutate_at(data_wide_imp,
                   vars(-c("Group", "Sample", ref)),
                   list(dCt = ~ . - .data[[ref]]))
  dCt <- select(dCt, Group, Sample, ends_with("dCt"))
  colnames(dCt) <- sub("_dCt*", "", colnames(dCt))
  cat("Data contained", nas, "missing values that constitute", round(percentage*100, 5), "percent of the total data.\n Missing values were imputed using means within compared groups.")
  if (save.to.txt == TRUE){
    write.table(as.data.frame(dCt), paste(name.txt,".txt", sep = ""))
  }
  return(dCt)
  
  } else {
    
    data_wide <- data %>%
      select(Group, Sample, Target, mean) %>%
      pivot_wider(names_from = Target, values_from = mean)
    nas <- sum(is.na(data_wide))
    percentage <- sum(is.na(data_wide))/((ncol(data_wide)-2)*nrow(data_wide))
    dCt <- mutate_at(data_wide,
                     vars(-c("Group", "Sample", ref)),
                     list(dCt = ~ . - .data[[ref]]))
    dCt <- select(dCt, Group, Sample, ends_with("dCt"))
    colnames(dCt) <- sub("_dCt*", "", colnames(dCt))
    cat("Data contains", nas, "missing values that constitute", round(percentage*100, 5), "percent of the total data.")
    if (save.to.txt == TRUE){
      write.table(as.data.frame(dCt), paste(name.txt,".txt", sep = ""))
    }
    return(dCt)
  }
}

table(CtF$Target)
dCt_noimput <- deltaCt(CtF, imput.by.mean.within.groups = FALSE, ref = "Gene1", save.to.txt = TRUE)
dCt_imput <- deltaCt(CtF, imput.by.mean.within.groups = TRUE, ref = "Gene1", save.to.txt = TRUE)


view(dCt_imput)
sum(is.na(dCt_imput))
sum(is.na(dCt_noimput))





#summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
#which(is.na(data_ok_wide), arr.ind = TRUE)
#sum(is.na(data_ok_wide))/((ncol(data_ok_wide)-2)*nrow(data_ok_wide))




#########   KONTROLA DCT BOXPLOT #######


control_dCt_boxplot <- function(data, coef = 1.5,
                               col = c("#66c2a5", "#fc8d62"),
                               axis.title.size = 12,
                               axis.text.size = 12,
                               x.axis.title = "Sample", y.axis.title = "dCt",
                               legend.title = "Group",
                               legend.title.size = 12,
                               legend.text.size = 12,
                               legend.position = "right",
                               plot.title = "",
                               dpi = 600, width = 15, height = 15,
                               save.to.tiff = FALSE,
                               name.tiff = "dCt_control_boxplot"){
  
    data <- pivot_longer(data, !c(Sample, Group), names_to = "Target" , values_to = "dCt")
    box_control <- ggplot(data, aes(x = Sample, y = dCt, color = Group)) +
      geom_boxplot(coef = coef) +
      scale_x_discrete(limits = rev(unique(data$Sample))) +
      scale_color_manual(values = c(col)) +
      coord_flip() +
      xlab(x.axis.title) + ylab(y.axis.title) +
      labs(fill = legend.title, title = plot.title) +
      theme_classic() +
      theme(legend.position = legend.position) +
      theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
      theme(axis.title = element_text(size = axis.title.size, colour="black")) +
      theme(legend.title = element_text(size = legend.title.size, colour="black")) +
      theme(legend.text = element_text(size = legend.text.size, colour="black"))
    print(box_control)
    if (save.to.tiff == TRUE){
      ggsave(paste(name.tiff,".tiff", sep = ""), box_control, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
    }
}  
    

control_dCt_boxplot(dCt_noimput,
                    col = c("#66c2a5", "#fc8d62"),
                    axis.title.size = 12,
                    axis.text.size = 12,
                    x.axis.title = "Sample", y.axis.title = "dCt",
                    legend.title = "Group",
                    plot.title = "",
                    dpi = 600, width = 15, height = 15,
                    save.to.tiff = TRUE)



#########   KONTROLA DCT CLUSTEROWANIE HIERARCHICZNE    #######


control_dCt_cluster <- function(data, method.dist = "euclidean", method.clust = "complete",
                                x.axis.title = "Samples", y.axis.title = "Height",
                                plot.title = "",
                                dpi = 600, width = 15, height = 15,
                                save.to.tiff = FALSE,
                                name.tiff = "dCt_control_clust_plot"){
  cluster <- hclust(dist(data, method = method.dist), method = method.clust)
  cluster$labels <- data$Sample
  plot(cluster, xlab  = x.axis.title, ylab = y.axis.title, main = plot.title)
  if (save.to.tiff == TRUE){
    tiff(paste(name.tiff, ".tiff", sep = ""), res = dpi, width = width, height = height, units = "cm", compression = "lzw")
    plot(cluster, xlab  = x.axis.title, ylab = y.axis.title, main = plot.title)
    dev.off()
  }
}

control_dCt_cluster(dCt_noimput, method.dist = "euclidean", method.clust = "average", save.to.tiff = TRUE)
control_dCt_cluster(dCt_imput, method.dist = "euclidean", method.clust = "average", save.to.tiff = TRUE)



#########   KONTROLA DCT PCA #######


######   Uwaga braki danych blokują analizę, więc usuwam próbki z brakami danych przed analizą!!!!
##########  Do PCA trzeba dać dane po imputacji, bo jak będzie NAs w każdum genie w jakiejś grupie to cała grupa zostanie usunięta i po analizie
control_dCt_pca <- function(data, point.size = 4, alpha = 0.7, label.size = 3,
                            col = c("#66c2a5", "#fc8d62"),
                            axis.title.size = 12,
                            axis.text.size = 10,
                            legend.text.size = 12,
                            legend.title = "Group",
                            legend.title.size = 12,
                            legend.position = "right",
                            plot.title = "",
                            dpi = 600, width = 15, height = 15,
                            save.to.tiff = FALSE,
                            name.tiff = "dCt_control_pca_plot"){
  data <- as.data.frame(data)
  rownames(data) <- data$Sample
  data <- na.omit(data)
  pca <- prcomp(select(data, -Sample, -Group))
  var_pca1 <- summary(pca)$importance[2,][1]
  var_pca2 <- summary(pca)$importance[2,][2]
  pca_comp <- as.data.frame(pca$x)
  pca_comp$Sample <- data$Sample
  pca_comp$Group <- data$Group
  control_pca <- ggplot(pca_comp, aes(x = PC1, y = PC2, label = Sample, color = Group)) +
    geom_point(size = point.size, alpha = alpha) + 
    scale_color_manual(values = c(col)) +
    labs(colour = legend.title, title = plot.title) + 
    theme_bw() + 
    labs(x = paste("PC1: ", round(var_pca1*100,2), "% variance explained", sep = ""),
         y = paste("PC2: ", round(var_pca2*100,2), "% variance explained", sep = "")) + 
    theme(legend.position = legend.position) + 
    theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
    theme(axis.title = element_text(size = axis.title.size, colour="black")) +
    theme(legend.text = element_text(size = legend.text.size, colour="black")) +
    theme(legend.title = element_text(size = legend.title.size, colour="black")) +
    geom_text(aes(label = Sample), hjust=0, vjust=-1, size = label.size)
  print(control_pca)
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff,".tiff", sep = ""), control_pca, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
}

control_dCt_pca(dCt_imput, col = c("#66c2a5", "#fc8d62"), save.to.tiff = TRUE)
control_dCt_pca(dCt_noimput, col = c("#66c2a5", "#fc8d62"), save.to.tiff = TRUE)

View(dCt_noimput)







#########   KONTROLA DCT KORELACJE #######

######   jak dużo braków danych to też nie pójdzie, lepiej po imputacji

library(tidyverse)
library("Hmisc")
library("corrplot")
control_dCt_corr <- function(data, add.coef = "black",
                             method = "pearson",
                             order = "hclust",
                             hclust.method = "complete",
                             size = 0.6,
                             save.to.tiff = FALSE,
                             dpi = 600, width = 15, height = 15,
                             name.tiff = "dCt_control_corr_plot",
                             save.to.txt = FALSE,
                             sort.txt = "cor",
                             name.txt = "dCt_control_corr_results",
                             p.adjust.method = "BH"){
  data <- as.data.frame(data)
  data <- select(data, -Group, -Sample)
  res_cor <- rcorr(as.matrix(data), type = method)
  if (order == "hclust"){
    corrplot(res_cor$r, type = "upper", tl.cex = size, tl.col = "black", cl.cex = size,
             order = order, 
             hclust.method = hclust.method,
             addCoef.col = add.coef,
             number.cex = size)
    if (save.to.tiff == TRUE){
      tiff(paste(name.tiff,".tiff", sep = ""), res = dpi, width = width, height = height, units = "cm", compression = "lzw")
      corrplot(res_cor$r, type = "upper", tl.cex = size, tl.col = "black", cl.cex = size,
               order = order, 
               hclust.method = hclust.method,
               addCoef.col = "black",
               number.cex = size)
      dev.off()
    }
  } else {
    corrplot(res_cor$r, type = "upper", tl.cex = size, tl.col = "black", cl.cex = size,
             order = order,
             addCoef.col = add.coef,
             number.cex = size)
    if (save.to.tiff == TRUE){
      tiff(paste(name.tiff,".tiff", sep = ""), res = dpi, width = width, height = height, units = "cm", compression = "lzw")
      corrplot(res_cor$r, type = "upper", tl.cex = size, tl.col = "black", cl.cex = size,
               order = order,
               addCoef.col = "black",
               number.cex = size)
      dev.off()
    }
  }
  if (save.to.txt == TRUE){
    corr <- upper.tri(res_cor$r)
    corr.data <- data.frame(
      row = rownames(res_cor$r)[row(res_cor$r)[corr]],
      column = rownames(res_cor$r)[col(res_cor$r)[corr]],
      cor  =(res_cor$r)[corr],
      p = res_cor$P[corr]
    )
    corr.data$p.adj <- p.adjust(corr.data$p, method = p.adjust.method)
    corr.data.sort <- arrange(corr.data, -abs(cor))
    write.table(corr.data.sort, paste(name.txt, ".txt", sep = ""))
  }
}


control_dCt_corr(dCt_noimput, order = "hclust",
                 hclust.method = "average",
                 size = 0.7,
                 add.coef = "black",
                 save.to.tiff = TRUE,
                 save.to.txt = TRUE)




library(ggpmisc)
single_dCt_corr <- function(data, x, y, alpha = 0.7,
                            by.group = FALSE,
                            col = c("#66c2a5", "#fc8d62"),
                            axis.title.size = 12,
                            axis.text.size = 10,
                            legend.text.size = 12,
                            legend.title = "Group",
                            legend.title.size = 12,
                            legend.position = "right",
                            plot.title = "",
                            label.position.x = 1,
                            label.position.y = 1,
                            label = c("eq", "R2", "p"),
                            dpi = 600, width = 15, height = 15,
                            save.to.tiff = FALSE,
                            name.tiff = "dCt_corr_single_plot"){
  if (by.group == TRUE){
    corr_control <- ggplot(data, aes(x = .data[[x]], y = .data[[y]], color = Group)) +
      geom_point() +
      geom_smooth(method='lm', se = FALSE, alpha = alpha) +
      stat_poly_eq(use_label(c("eq", "R2", "p")),
                   label.y = c(label.position.y),
                   label.x = c(label.position.x)) +
      scale_color_manual(values = c(col)) +
      xlab(x) + ylab(y) +
      labs(color = legend.title, title = plot.title) +
      theme_classic() +
      theme(legend.position = legend.position) +
      theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
      theme(axis.title = element_text(size = axis.title.size, colour="black")) +
      theme(legend.text = element_text(size = legend.text.size, colour="black")) +
      theme(legend.title = element_text(size = legend.title.size, colour="black"))
  } else {
    corr_control <- ggplot(data, aes(x = .data[[x]], y = .data[[y]])) +
      geom_point() +
      geom_smooth(method='lm', se = FALSE, alpha = alpha) +
      stat_poly_eq(use_label(label),
                   label.y = c(label.position.y),
                   label.x = c(label.position.x)) +
      xlab(x) + ylab(y) +
      labs(title = plot.title) +
      theme_classic() +
      theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
      theme(axis.title = element_text(size = axis.title.size, colour="black"))
    }
  print(corr_control)
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff,".tiff", sep = ""), corr_control, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
}  


single_dCt_corr(dCt_noimput, x = "Gene10", y = "Gene100", alpha = 0.7,
                    by.group = TRUE,
                    col = c("#66c2a5", "#fc8d62"),
                    axis.title.size = 12,
                    axis.text.size = 10,
                    legend.text.size = 12,
                    legend.title = "Group",
                    legend.position = "right",
                    plot.title = "",
                    dpi = 600, width = 15, height = 15,
                    save.to.tiff = TRUE,
                label.position.x = c(1,1),
                label.position.y = c(1,0.95))






#########   FILTROWANIE DCT    ##############

dCt_imput
filter_dCt <- function(data, 
                       remove.Target = c(""), 
                       remove.Sample = c(""), 
                       remove.Group = c("")){
  data <- dplyr::filter(data,
                        !Sample %in% remove.Sample,
                        !Group %in% remove.Group)
  data <- select(data, -any_of(remove.Target))
  return(data)
}


dCt_noimput_F <- filter_dCt(dCt_noimput, remove.Sample = c("KL11", "L62","L38","L39"))
dCt_imput_F <- filter_dCt(dCt_imput, remove.Sample = c("KL11", "L62","L38","L39"))


#########   RESULTS DCT BOXPLOT #######


results_dCt_boxplot <- function(data, coef = 1.5, sel.Target = "all", angle = 0, rotate = FALSE, add.mean = FALSE,
                                add.mean.size = 2,
                                add.mean.color = "black",
                                col = c("#66c2a5", "#fc8d62"),
                                axis.title.size = 12,
                                axis.text.size = 10,
                                legend.text.size = 12,
                                x.axis.title = "Sample",
                                y.axis.title = "dCt",
                                legend.title = "Group",
                                legend.title.size = 12,
                                legend.position = "right",
                                plot.title = "",
                                dpi = 600, width = 15, height = 15,
                                save.to.tiff = FALSE,
                                name.tiff = "dCt_results_boxplot"){
  
  data <- pivot_longer(data, !c(Sample, Group), names_to = "Target" , values_to = "dCt")
  if (sel.Target[1] == "all"){
    data <- data
  } else {
    data <- filter(data, Target %in% sel.Target)
  }
  box_results <- ggplot(data, aes(x = Target, y = dCt, fill = Group)) +
    geom_boxplot(coef = coef) +
    #scale_x_discrete(limits = rev(unique(data$Sample))) +
    scale_fill_manual(values = c(col)) +
    #coord_flip() +
    xlab(x.axis.title) + ylab(y.axis.title) +
    labs(fill = legend.title, title = plot.title) +
    theme_bw() +
    theme(legend.position = legend.position) +
    theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
    theme(axis.title = element_text(size = axis.title.size, colour="black")) +
    theme(legend.text = element_text(size = legend.text.size, colour="black")) +
    theme(legend.title = element_text(size = legend.title.size, colour="black")) +
    theme(panel.grid.major.x = element_blank())
  if (angle != 0){
    box_results <- box_results +
      guides(x =  guide_axis(angle = angle))
  }
  if (rotate == TRUE){
    box_results <- box_results +
      coord_flip()
  }
  if (add.mean == TRUE){
    box_results <- box_results +
      stat_summary(aes(group = Group), 
                   fun = mean, 
                   position = position_dodge(width = .75), 
                   geom = "point", 
                   shape = 15, 
                   size = add.mean.size, 
                   color = add.mean.color)
  }
  print(box_results)
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff,".tiff", sep = ""), box_results, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
}  


results_dCt_boxplot(dCt_imput, coef = 1.5, sel.Target = "all", angle = 45, rotate = FALSE, add.mean = TRUE,
                    col = c("#66c2a5", "#fc8d62"),
                    axis.title.size = 12,
                    axis.text.size = 12,
                    legend.text.size = 12,
                    legend.title.size = 12,
                    x.axis.title = "Target",
                    y.axis.title = "dCt",
                    legend.title = "Group",
                    legend.position = "top",
                    plot.title = "",
                    dpi = 600, width = 15, height = 15,
                    save.to.tiff = TRUE)




#########   DDCT    ##############

# tylko dla dwóch grup, pierwsza to badana, druga to kontrolna

ddCt <- function(data, 
                 group.study,
                 group.ref,
                 do.tests = TRUE,
                 save.to.txt = FALSE,
                 name.txt = "ddCt_RQ_results"){
  
  data_slim <- data %>%
    filter(Group == group.study | Group == group.ref) %>%
    pivot_longer(cols = -c(Group, Sample), names_to = "Target", values_to = "dCt")
  data_ddCt <- data_slim %>%
    group_by(Group, Target) %>%
    summarise(ddCt = mean(dCt, na.rm = TRUE)) %>%
    pivot_wider(names_from = Group, values_from = ddCt) %>%
    mutate(ddCt = .data[[group.study]] - .data[[group.ref]]) %>%
    mutate(RQ = 2^-ddCt) %>%
    rename_with(~paste0(.x, "_mean", recycle0 = TRUE), all_of(c(group.study, group.ref)))
  if (do.tests == TRUE){
  data_ddCt_norm <- data_slim %>%
    group_by(Group, Target) %>%
    summarise(shap_wilka_p = shapiro.test(dCt)$p.value) %>%
    pivot_wider(names_from = Group, values_from = shap_wilka_p) %>%
    full_join(data_ddCt, by = c("Target")) %>%
    mutate(test.for.comparison = ifelse(.data[[group.ref]] >= 0.05 & .data[[group.study]] >= 0.05, "t.student's.test", "Mann-Whitney.test")) %>%
    rename_with(~paste0(.x, "_norm_p", recycle0 = TRUE), all_of(c(group.study, group.ref)))
  data_ddCt_tests <- data_slim %>%
    group_by(Target) %>%
    summarise(t.test.p = t.test(dCt ~ Group, alternative = "two.sided")$p.value,
              t.test.stat = t.test(dCt ~ Group, alternative = "two.sided")$statistic,
              MW.test.p = wilcox.test(dCt ~ Group, alternative = "two.sided")$p.value,
              MW.test.stat = wilcox.test(dCt ~ Group, alternative = "two.sided")$statistic)
  data_ddCt_norm_tests <- full_join(data_ddCt_norm, data_ddCt_tests, by = c("Target"))
  return(data_ddCt_norm_tests)
  } else{
    return(data_ddCt)
  }
  if (save.to.txt == TRUE){
    write.table(data_ddCt_norm_tests, paste(name.txt,".txt", sep = ""))
  }
}


ddCt_results_noimp <- ddCt(dCt_noimput, do.tests = FALSE,
                           group.study = "Condition1",
                           group.ref = "Condition2",
                           save.to.txt = TRUE,
                           name.txt = "ddCt_noimput")
ddCt_results_imp <- ddCt(dCt_imput, do.tests = TRUE,
                         group.study = "Condition1", 
                         group.ref = "Condition2", 
                         save.to.txt = TRUE, 
                         name.txt = "ddCt_imput")






#########   RQ plot    ##############


# my.name <- readline(prompt="Enter name: ")
# my.age <- readline(prompt="Enter age: ")
# # convert character into integer
# my.age <- as.integer(my.age)
# print(paste("Hi,", my.name, "next year you will be", my.age+1, "years old."))


#pierwsza kolumna ma miec nazwy targetów, a druga "t" lub "mw" tylko.
user <- as.data.frame(ddCt_results_imp$Target)
user$test <- c("t","t","t","t","t","t","t","t","t","t","t","t","mw","mw")
user
#  zrób user z danych ddCt

colnames(RQdata)
user <- select(RQdata, Target, test.for.comaprison)




RQ_plot <- function(data, use.p = TRUE, mode, Target.sel = "all", p.threshold = 0.05,
                    col.width = 0.8,
                    angle = 0, rotate = FALSE,
                    col = c("#66c2a5", "#fc8d62"),
                    axis.title.size = 12,
                    axis.text.size = 10,
                    legend.text.size = 12,
                    x.axis.title = "Target",
                    y.axis.title = "log10(RQ)",
                    legend.title = "Statistically significant?",
                    legend.title.size = 12,
                    legend.position = "top",
                    plot.title = "",
                    dpi = 600, width = 15, height = 15,
                    save.to.tiff = FALSE,
                    name.tiff = "ddCt_RQ_plot"){
  if (Target.sel[1] != "all"){
    data <- filter(data, Target %in% Target.sel)
  }
  if (use.p == TRUE){
  if (mode == "t"){
    data$p.used <- data$t.test.p
    }
  if (mode == "mw"){
    data$p.used <- data$MW.test.p
    }
  if (mode == "depends"){
    data <- mutate(data, p.used = ifelse(test.for.comaprison == "t.student's.test", yes = t.test.p,  no = MW.test.p))
  }
  if (mode == "user"){
    colnames(user) <- c("Target","test")
    data <- full_join(data, user, by = c("Target"))
    data <- mutate(data, p.used = ifelse(test == "t.student's.test", yes = t.test.p,  no = MW.test.p))
  }
  data <- mutate(data, `Statistically significant?` = ifelse(p.used > p.threshold, yes = "No (p > 0.05)",  no = "Yes (p <= 0.05)"))
  data$`Statistically significant?` <- factor(data$`Statistically significant?`, levels = c("Yes (p <= 0.05)", "No (p > 0.05)"))
  RQ <- ggplot(data, aes(x = reorder(Target, -RQ), y = log10(RQ), fill = `Statistically significant?`)) +
    geom_col(width = col.width) +
    scale_fill_manual(values = c(col)) +
    xlab(x.axis.title) + ylab(y.axis.title) +
    labs(fill = legend.title, title = plot.title) +
    theme_bw() +
    theme(legend.position = legend.position) +
    theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
    theme(axis.title = element_text(size = axis.title.size, colour="black")) +
    theme(legend.text = element_text(size = legend.text.size, colour="black")) +
    theme(legend.title = element_text(size = legend.title.size, colour="black")) +
    theme(panel.grid.major.x = element_blank()) +
    geom_hline(yintercept = 0, linewidth = 0.4)
  } else {
    RQ <- ggplot(data, aes(x = reorder(Target, -RQ), y = log10(RQ))) +
      geom_col(width = col.width, fill = col[1]) +
      xlab(x.axis.title) + ylab(y.axis.title) +
      labs(title = plot.title) +
      theme_bw() +
      theme(legend.position = legend.position) +
      theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
      theme(axis.title = element_text(size = axis.title.size, colour="black")) +
      theme(legend.text = element_text(size = legend.text.size, colour="black")) +
      theme(legend.title = element_text(size = legend.title.size, colour="black")) +
      theme(panel.grid.major.x = element_blank())
  }
  
  if (angle != 0){
    RQ <- RQ +
      guides(x =  guide_axis(angle = angle))
  }
  if (rotate == TRUE){
    RQ <- RQ +
      coord_flip()
  }
  print(RQ)
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff,".tiff", sep = ""), RQ, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
  return(data)
}


RQ_plot(ddCt_results_noimp, use.p = FALSE, col = "red", mode = "depends", angle = 45, save.to.tiff = TRUE)
RQdata <- RQ_plot(ddCt_results_imp, mode = "user", angle = 45, save.to.tiff = TRUE)


sign.tar <- filter(RQdata, p.used < 0.05)$Target

RQ_plot(ddCt_results_noimp, use.p = FALSE, Target.sel = sign.tar, col = "red", mode = "depends", angle = 45, save.to.tiff = TRUE)



#########   ROC    ##############

# tu chyba musi być imputacja, a dane muszą zawierac dwie grupy
library(tidyverse)
library(pROC)

ROC <- function(data,
                Target.sel = "all",
                Groups,
                save.to.tiff = FALSE, plot.title = "",
                dpi = 600, width = 15, height = 15,
                panels.row,
                panels.col,
                name.tiff = "dCt_ROC_plot",
                text.size = 1.1,
                print.auc = TRUE,
                print.auc.cex = 0.8,
                save.to.txt = FALSE,
                name.txt = "dCt_ROC_results"){
  data <- filter(data, Group %in% Groups)
  if (Target.sel[1] != "all"){
    data <- data[, colnames(data) %in% c("Group", "Sample", Target.sel)]
  }
  roc_param <- as.data.frame(matrix(nrow = ncol(data)-2, ncol = 10))
  colnames(roc_param) <- c("Target","Threshold", "Specificity", "Sensitivity", "Accuracy", "ppv", "npv", "youden", "AUC", "Target.control")
  roc_param$Target <- colnames(data)[-c(1:2)]
  for (x in 1:nrow(roc_param)){
    myproc <- roc(response = data$Group, predictor = as.data.frame(data)[ ,x+2], levels = c(Groups), 
                  smooth = FALSE, auc = TRUE, plot=FALSE, ci=TRUE, of = "auc")
    parameters <- coords(myproc, "best", ret = c("threshold", "specificity", "sensitivity","accuracy", "ppv", "npv", "youden"))
    roc_param[x,2:8] <- parameters
    roc_param[x,9] <- myproc$auc
    roc_param[x,10] <- colnames(data)[x+2]
  }
  if (save.to.tiff == TRUE){
    tiff(paste(name.tiff,".tiff", sep = ""), res = dpi, width = width, height = height, units = "cm", compression = "lzw")
    par(mfrow = c(panels.row, panels.col))
    for (x in 1:nrow(roc_param)){
      myproc <- roc(response = data$Group, predictor = as.data.frame(data)[ ,x+2], levels = c(Groups), 
                    smooth = FALSE, auc = TRUE, plot=FALSE, ci=TRUE, of = "auc")
      plot.roc(myproc, main = roc_param$Target[x], 
               smooth = FALSE, cex.axis = text.size, cex.lab = text.size, identity.lwd = 2, 
               plot = TRUE, percent = TRUE, print.auc = print.auc, print.auc.x = 0.85, print.auc.y = 0.1, print.auc.cex = print.auc.cex)
    }
    dev.off()
  }
  if (save.to.txt == TRUE){
    write.table(roc_param, paste(name.txt,".txt", sep = ""))
  }
  return(roc_param)
}

ncol(dCt_imput)-2
ROC(dCt_imput, Groups = c("A","B"), save.to.tiff = TRUE, panels.row = 37, panels.col = 4, save.to.txt = TRUE, height = 180)
ROC(dCt_noimput, Groups = c("A","B"), save.to.tiff = TRUE, panels.row = 37, panels.col = 4, height = 180)



#data_mean <- data_ok_wide %>%
#  select(-Sample) %>%
#  group_by(Group) %>%
#  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))









#########   REGRESJA LOGISTYCZNa    ##############

library(oddsratio)

####  Jeżeli z analizy wyjdą wartości inf lub NA, to są usuwane
log_reg <- function(data, remove.Inf.NA = FALSE,
                    Target.sel = "all",
                    group.study,
                    group.ref,
                    ci = 0.95,
                    axis.title.size = 12,
                    axis.text.size = 10,
                    legend.text.size = 12,
                    x.axis.title = "Odds ratio",
                    y.axis.title = "",
                    legend.title = "p value",
                    legend.title.size = 12,
                    legend.position = "right",
                    plot.title = "",
                    dpi = 600, width = 15, height = 15,
                    save.to.tiff = FALSE,
                    name.tiff = "dCt_OR_plot",
                    save.to.txt = FALSE,
                    name.txt = "dCt_OR_results",
                    log.axis = FALSE){
  data <- filter(data, Group %in% c(group.study, group.ref))
  if (Target.sel[1] != "all"){
    data <- data[, colnames(data) %in% c("Group", "Sample", Target.sel)]
  }
  data <- mutate(data, Group_num = ifelse(Group == group.ref, 0, 1))
  n.targets <- ncol(data)-3
  list.models <- lapply(data[3:(n.targets+2)], function(x) glm(data$Group_num ~ x, data = data, family = binomial))
  list.CI <- lapply(names(list.models)[1:n.targets], function(x) or_glm(data = data,
                                                           model = list.models[[x]],
                                                           incr = list(x = 1),
                                                           ci = ci))
  data.CI <- as.data.frame(matrix(ncol = 8, nrow = n.targets))
  colnames(data.CI) <- c("Target", "oddsratio", "CI_low", "CI_high", "Intercept", "coeficient","p_intercept","p_coef")
  for (x in 1:n.targets){
    data.CI$Target <- names(list.models)
    data.CI[x,2:4] <- as.vector(list.CI)[[x]][2:4]
    data.CI[x,5:6] <- list.models[[x]]$coefficients
    data.CI[x,7:8] <- coef(summary(list.models[[x]]))[,4]
  }
  od_df <- data.frame(yAxis = 1:nrow(data.CI),
                        boxOdds = data.CI$oddsratio,
                        boxCILow = data.CI$CI_low,
                        boxCIHigh = data.CI$CI_high,
                        boxLabels = data.CI$Target,
                        p = data.CI$p_coef)
  
  if (remove.Inf.NA == TRUE){
    od_df[sapply(od_df, is.infinite)] <- NA
    od_df <- na.omit(od_df)
  }
  
  odd.ratio <- ggplot(od_df, aes(x = boxOdds, y = boxLabels, label = boxOdds)) +
    geom_vline(aes(xintercept = 1), linewidth = .25, linetype = "dashed") +
    geom_errorbarh(aes(xmax = boxCIHigh, xmin = boxCILow), linewidth = .5, height = .2) +
    geom_point(aes(color = p), size = 3.5) + 
    scale_color_continuous(type = "viridis") +
    geom_text(aes(label = boxOdds), hjust=0.5, vjust = -1, size = 3) +
    xlab(x.axis.title) + ylab(y.axis.title) +
    labs(color = legend.title, title = plot.title) +
    theme_bw() +
    theme(legend.position = legend.position) +
    theme(axis.text = element_text(size = axis.text.size, colour = "black")) +
    theme(axis.title = element_text(size = axis.title.size, colour="black")) +
    theme(legend.text = element_text(size = legend.text.size, colour="black")) +
    theme(legend.title = element_text(size = legend.title.size, colour="black"))
  if (log.axis == TRUE){
    odd.ratio <- odd.ratio +
      scale_x_log10()
  }
  print(odd.ratio)
  if (save.to.tiff == TRUE){
    ggsave(paste(name.tiff,".tiff", sep = ""), odd.ratio, dpi = dpi, width = width, height = height, units = "cm", compression = "lzw")
  }
  if (save.to.txt == TRUE){
    write.table(data.CI, paste(name.txt,".txt", sep = ""))
  }
  return(data.CI)
}



log_reg(dCt_imput, group.study = "C", group.ref = "B", ci = 0.95, save.to.tiff = TRUE, save.to.txt = TRUE, height = 50,
        log.axis = TRUE, remove.Inf.NA = TRUE)
log_reg(dCt_noimput, group.study = "A", group.ref = "B", ci = 0.95, save.to.tiff = TRUE, save.to.txt = TRUE)



library(tidyverse)
