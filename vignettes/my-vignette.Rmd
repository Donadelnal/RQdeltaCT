---
title: "RQdeltaCT - relative quantification of gene expression using delta Ct methods"
output: rmarkdown::html_vignette
author: "Daniel Zalewski daniel.piotr.zalewski@gmail.com"
date: "19 February 2024"
vignette: >
  %\VignetteIndexEntry{RQdeltaCT - relative quantification of gene expression using delta Ct methods}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  cache = FALSE
)
```

## Introduction
`RQdeltaCT` is a R packege developed to perform relative quantification of gene expression using delta Ct methods, proposed by Kenneth J. Livak and Thomas D. Schmittgen in [Article1](https://www.sciencedirect.com/science/article/pii/S1046202301912629?via%3Dihub) and [Article2](https://www.nature.com/articles/nprot.2008.73).

These methods were designed to analyze gene expression data (Ct values) obtained from real-time PCR experiments. The main idea is to normalize gene expression values using endogenous control gene, present gene expression levels in linear form by using 2^-(value)^ transformation, and calculate differences in gene expression levels between groups of samples (or technical replicates of single sample).

There are three main delta Ct methods used for relative quantification. Choice of the best method depends on the study design. Short description of these methods are provided below, for more details refer to articles in links provided above.

1. 2^-Ct^ method. This method can be used in studies where several genes are tested if they are influenced by studied experimental condition and are suitable to be used as reference genes (also called endogenous controls or internal controls). Raw Ct values obtained from experiments are transformed using 2^-Ct^ formula, summarized by means in compared study conditions, and a ratio of means (fold change) is calculated for experimental condition. If obtained fold change value is assessed as significant, gene would be not a good choice for reference gene. See example no 3 in [Article2](https://www.nature.com/articles/nprot.2008.73).  

2. 2^-dCt^ method. In this method, Ct values are normalized by endogenous control gene (often GAPDH, beta-actin, or other) by subtracting Ct value of endogenous control in each sample from Ct value of gene gene in the same samples, obtaining delta Ct (dCt) values. Subsequently, dCt values are transformed using 2^-dCt^ formula, summarized by means in compared study groups, and a ratio of means (fold change) is calculated for a study group. This method is useful in scenarios where samples should be analyzed as individual data points, e.g. in comparison between patients and healthy subjects. See example no 5 in [Article2](https://www.nature.com/articles/nprot.2008.73).

3. 2^-ddCt^ method. Similarly to 2^-dCt^ method, Ct values are normalized by endogenous control gene, but obtained delta Ct (dCt) values are not exponentially transformed, but summarized by means in compared study groups, and mean dCt in a control group is subtracted from mean dCt in a study group, giving delta delta Ct (ddCt) value. Subsequently, ddCt values are transformed using 2^-ddCt^ formula to obtain fold change value (also called RQ value). This method is useful where a compared groups contain rather technical than biological replicates, e.g. where samples of cell line before adding stimulant are compared to samples of cell line after stimulation. See examples no 1 and 2 in [Article2](https://www.nature.com/articles/nprot.2008.73).  

Presented `RQdeltaCT` package includes functions that encompass all of these methods. Selection of proper method for analysis is up to the user.  

Functions developed within `RQdeltaCT` package are designed to be maximally easy to use, even for the users who are beginners to R. The parameters of functions were prepared to sufficiently ranged all essential tasks and options, and no additional, extensive coding steps are necessary in standard workflow. The package was developed in the intention to make an opportunity to perform relative quantification analysis of gene expression using `RQdeltaCT` by no experts in R programming (only a very basic skills are required).   

The summary of standard workflow, including function names and data flow was presented below:  

```{r echo=FALSE, out.width="650px", dpi = 600, fig.align="center", warning=FALSE, message=FALSE, cache=FALSE}
library(here)
knitr::include_graphics(file.path(here::here(),"vignettes", "figure", "figure1ok.png"))

```

The whole standard workflow of analysis performed using `RQdeltaCT` package requires the following external packages: 

* `tidyverse` - main package for data processing (`dplyr`, `tidyr`) and visualisation (`ggplot2`),
* `coin` - used to perform Mann-Whitney U test (`wilcox_test()` function),
* `car` - used to compute VIF coefficients (`vif()` function),
* `ctrlGene` - used to calculate gene expression stability score using geNorm algorithm,
* `ggsignif` - used to add significance labels to plots,
* `Hmisc` - used to perform correlation analysis (`rcor()` function),
* `corrplot` - used to visualise results of correlation analysis (`corrplot()` function),
* `ggpmisc` - used to add linear regression results to plot (`stat_poly_eq()` function),
* `pROC` - used to perform analysis (`roc()` function),
* `oddsratio` - used to compute odds ratio values (`or_glm()` function).  

All plots created by functions of `RQdeltaCT` package can be saved as a .tiff files in working directory (if `save.to.tiff` parameter is set to TRUE). Image resolution, dimensions and name can be specified by the user. Also all generated tables can be saved as .txt files (if `save.to.txt` parameter is set to TRUE) with name specified by the user.

This vignette include instructions and examples of usage of main parameters of functions from `RQdeltaCT` package. For all list of parameters available and their instructions refer to documentation of a particular function.

---

## Data import
Data analyzed with `RQdeltaCT` package should be in tabular form and contain the following information: group names, sample names, gene names and Ct values. Flag information can be also included for data filtering purpose. Any other information could exist in data (user do not have to remove them), but will not be used for analysis.

Files with such a tables typically can be exported from software coupled with PCR devices and used to analysis of raw data files generated during real-time PCR experiments. Such a files are also returned by external software, such as [SDS](https://www.thermofisher.com/pl/en/home/technical-resources/software-downloads/applied-biosystems-7900ht-fast-real-timespcr-system.html), or even R packages, e.g. [qpcR](https://academic.oup.com/bioinformatics/article/24/13/1549/238435)   

For user convenience, `RQdeltaCT` package provides two functions useful to import tables in .txt format:
* `read_Ct_long()` - to import tables with long-format structure (each information in columns),
* `read_Ct_wide()` - to import tables with wide-format structure (samples by columns, genes by rows).  

**NOTE:** Imported tables must be free from empty lines.  

#### 1. Reading long-format data using `read_Ct_long()` function.

Example of long-format table with structure suitable for `read_Ct_long()` function.:

| Group | Sample | Gene | Ct | Flag |
|:--------|:---------|:------|:-----|:----|
| Disease | Disease1 | Gene1 | 25.6 | OK |
| Disease | Disease2 | Gene2 | 32.9 | Undetermined |
| Control | Control1 | Gene1 | Undetermined | OK |
| Control | Control2 | Gene2 | 27.5 | OK |
| ... | ... | ... | ... | ...|


For the purpose of presentation of `read_Ct_long()` function, this function  will be used to import long-format .txt table (data_Ct_long.txt) located in `RQdeltaCt` package directory:

```{r message=FALSE, cache=FALSE}
# Set path to file:
path <- system.file("extdata",
                    "data_Ct_long.txt",
                    package = "RQdeltaCT")

# Import file using path, remember to specify proper separator, decimal character and numbers of necessary columns:
library(RQdeltaCT)
library(tidyverse)
data.Ct <- read_Ct_long(path = path,
                        sep = "\t",
                        dec = ".",
                        skip = 0,
                        add.column.Flag = TRUE,
                        column.Sample = 1,
                        column.Gene = 2,
                        column.Ct = 5,
                        column.Group = 9,
                        column.Flag = 4)
```

Let's look at the data structure:
```{r cache=FALSE}
str(data.Ct)
```

The data were imported properly; however, Flag variable is numeric, but character or factor is required. The Flag column contains numeric AmpScore parameter, which is often used to evaluate a quality of amplification curve - curves with AmpScore below 1 are typically considered as low quality and removed from data during analysis. We can change Flag variable into character by transforming numeric AmpScore parameter to binary variable containing "OK" and "Undetermined" values based on the applied AmpScore criterion:

```{r, cache=FALSE}
library(tidyverse)
data.Ct <- mutate(data.Ct,
                  Flag = ifelse(Flag < 1, "Undetermined", "OK"))
str(data.Ct)
```

In this transformation, all AmpScore values in Flag column which are below 1 were changed to "Undetermined", otherwise to "OK". Flag variable now is character, as required, and data is ready to further steps of analysis.

#### 2. Reading wide-format data using `read_Ct_wide()` function.

The `read_Ct_wide()` function was designed to import data with gene expression results in form of a wide-format table (with sample names in the first row and gene names in first column). Because such a structure do not includes names of groups, additional file is required, containing groups names and assigned samples. This second file must contain two columns: column named "Sample" with names of samples and column named "Group" with names of groups assigned to samples. Names of samples in this file must be the same as names of columns in file with Ct values (the order does not have to be kept).

Example structure of wide-format table suitable for `read_Ct_wide()` function:

| Gene | Sample1 | Sample2 | Sample3 | ... |
|:--------|:---------|:------|:-----|:----|
| Gene1 | 25.4 | 24.9 | 25.6 | ... |
| Gene2 | 21.6 | 22.5 | 20.8 | ... |
| Gene3 | 33.7 | Undetermined | Undetermined | ... |
| Gene4 | 15.8 | 16.2 | 17.5 | ... |
| ... | ... | ... | ... | ...|

Example structures of additional file suitable for `read_Ct_wide()` function:

| Sample | Group |
|:--------|:--------|
| Sample1 | Control |
| Sample2 | Control |
| Sample3 | Disease |
| Sample4 | Disease |
| ... | ... |

In the next example, `read_Ct_wide()` function was used to import and merge wide-format file with Ct values (data_Ct_wide.txt) and file with names of groups (data_design.txt) located in `RQdeltaCt` package directory:

```{r cache=FALSE}
# Set a paths to required files: 
path.Ct.file <- system.file("extdata",
                            "data_Ct_wide.txt",
                            package = "RQdeltaCT")
path.design.file <- system.file("extdata",
                                "data_design.txt",
                                package = "RQdeltaCT")

# Import files:
library(tidyverse)
data.Ct <- read_Ct_wide(path.Ct.file = path.Ct.file,
                        path.design.file = path.design.file,
                        sep ="\t",
                        dec = ".")

# Look at the structure:
str(data.Ct)
```

Table imported from the package data object can be directly subjected to further steps of analysis. 

---

It also can be a situation, in which intended to import wide-format table has samples by rows and genes by columns. There is no need to develop separate function to import file with such a table, we can do:

```{r cache=FALSE}
# Import file, be aware to specify parameters that fit to imported data:
data.Ct.wide <- read.csv(file = "data/data.Ct.wide.vign.txt",
                         header = TRUE,
                         sep = ",")
str(data.Ct.wide)

# Imported table is now transformed to long-format structure. X column is unnecessary and is removed. All variables are converted to character to unify class of variables.
library(tidyverse)
data.Ct <- data.Ct.wide %>%
             select(-X) %>%
             mutate(across(everything(), as.character)) %>%
             pivot_longer(cols = -c(Group, Sample), names_to = "Gene", values_to = "Ct")
str(data.Ct)
```
**NOTE:** At this stage, Ct values do not have to be numeric.

**NOTE:** Data can be also imported to R using user own code, but the final object must be data frame and contain table with column named "Sample" with sample names, column named "Gene" with gene names, column named "Ct" with raw Ct values, column named "Group" with groups names, and optionally column named "Flag" that contain flag information (this column should be class of character or factor).

---

For package testing purpose, there is also a convenient possibility to use data object included in `RQdeltaCT` package, named `data.Ct`:

```{r cache=FALSE}
data(data.Ct)
str(data.Ct)
```

---

## Quality control of raw Ct data

The crucial step of each data analysis is an assessment of quality and usefulness of data used to investigate studied problem. The `RQdeltaCT` package offers two functions to quality control of raw Ct data: `control_Ct_barplot_sample()` (for quality control of samples) and  `control_Ct_barplot_gene()` (for quality control of genes). Both functions require to specify quality control criteria to be applied to Ct values, in order to label each Ct value as reliable or not. These functions return numbers of reliable and unreliable Ct values in each samples or each gene, as well as all Ct values obtained from each sample and each gene. These results are presented graphically on barplots. Obtained results are useful to inspect analyzed data in order to identify samples and genes that should be considered to be removed from data (based on applied reliability criteria).  

Three selection criteria can be set in these functions:  

* a flag used for undetermined Ct values. Default to "Undetermined".
* a maximum of Ct value allowed. Default to 35.
* a flag used in Flag column for values which are unreliable. Default to "Undetermined".

**NOTE:** This function does not perform data filtering, but only numbers Ct values labeled as reliable or not and presents them graphically.  

An example of using these functions are provided below:

```{r fig.dim=c(7.1,7), cache=FALSE}
sample.Ct.control <- control_Ct_barplot_sample(data = data.Ct,
                                               flag.Ct = "Undetermined",
                                               maxCt = 35,
                                               flag = c("Undetermined"),
                                               axis.title.size = 9,
                                               axis.text.size = 7,
                                               plot.title.size = 9,
                                               legend.title.size = 9,
                                               legend.text.size = 9)

```
```{r fig.dim=c(7.1,5.5), cache=FALSE}
gene.Ct.control <- control_Ct_barplot_gene(data = data.Ct,
                                               flag.Ct = "Undetermined",
                                               maxCt = 35,
                                               flag = c("Undetermined"),
                                               axis.title.size = 9,
                                               axis.text.size = 9,
                                               plot.title.size = 9,
                                               legend.title.size = 9,
                                               legend.text.size = 9)
```


Created plots are displayed on the graphic device, and short information about returned tables appears. Returned objects are lists that contain two elements: object with plot and table with numbers of Ct values labeled as reliable (Yes) and unreliable (No), as well as fraction of unreliable Ct values in each gene. In order to easy identify samples or genes with low quality, tables are sorted by descending number of unreliable values. To access returned tables, the second element of returned objects should be called:

```{r cache=FALSE}
head(sample.Ct.control[[2]])
```

```{r cache=FALSE}
head(gene.Ct.control[[2]])
```

Visual inspection of returned plots and obtained tables give clear image of data quality as well as numbers of samples analyzed for each gene and numbers of genes analyzed in each sample. Results obtained in the examples show that Disease group contains more samples than Control group. Some of the samples have more Ct values (more technical replicates) than other samples. Furthermore, in all samples, a majority of Ct values are reliable.  

Regarding genes, Gene6 and Gene8 were analyzed in duplicates, other genes have single Ct values. Furthermore, Gene6 was analysed only in Control group and have all values labeled as unreliable; therefore, it is obvious that this gene should be excluded from the analysis. Some other genes have also many unreliable Ct values (e.g. Gene2, Gene9) and maybe should be considered to be removed from the data.  


In some situations, unified fraction of unreliable data need to be establish and used to make decision which samples or genes should be excluded from the analysis. It can be done using the following code, in which the second element of object returned by `control_Ct_barplot_sample()` or `control_Ct_barplot_gene()` functions can be used directly, and a vector with samples or genes for which the fraction of unreliable Ct values is higher than a specified threshold is received: 

```{r cache=FALSE}
# Finding samples with more than half unreliable Ct values.
low.quality.samples <- filter(sample.Ct.control[[2]], Not.reliale.fraction > 0.5)$Sample
low.quality.samples <- as.vector(low.quality.samples)                        
low.quality.samples

# Finding genes with more than half unreliable Ct values in given group.
low.quality.genes <- filter(gene.Ct.control[[2]], Not.reliable.fraction > 0.5 & Group == "Disease")$Gene
low.quality.genes <- as.vector(low.quality.genes)                        
low.quality.genes
```

In examples above, there is no sample with more than half unreliable data. Further, this criterion was met by 5 genes (Gene2, Gene5, Gene6, Gene9, and Gene11); therefore, these genes will be removed from data in the next step of analysis. 

---

## Filtering of raw Ct data

When reliability criteria are finally established for Ct values, and some samples or genes are decided to be excluded from the analysis after quality control of data, data with raw Ct values can be filtered using `filter_Ct()` function.  

As a filtering criteria, a flag used for undetermined Ct values, a maximum of Ct threshold, and a flag used in Flag column can be applied. Furthermore, vectors with samples, genes, and groups to be removed can be also specified:

```{r cache=FALSE}
# Objects returned from `low_quality_samples()` and `low_quality_genes()`functions can be used directly:
data.CtF <- filter_Ct(data = data.Ct,
                      flag.Ct = "Undetermined",
                      maxCt = 35,
                      flag = c("Undetermined"),
                      remove.Gene = low.quality.genes,
                      remove.Sample = low.quality.samples)

# Check dimensions of data before and after filtering:
dim(data.Ct)
dim(data.CtF)
```

**NOTE:** If data contain more than two groups, it is good practice to remove groups that are out of comparison; however, a majority further functions can deal with more groups unless only two groups are indicated to be given in function's parameters.

---

## Collapsing technical replicates and imputation of missing data - `make_Ct_ready()` function

In the next step, filtered Ct data can be subjected to collapsing of technical replicates and (optional) data imputation by means within groups using `make_Ct_ready()` function. 'Technical replicates' term means observations with the same group name, gene name and sample name. In the scenario when data contain technical replicates, but they should not be collapsed, these technical replicates must be distinguished by different sample names, e.g. Sample1_1, Sample1_2, Sample1_3, etc.  

The parameter `imput.by.mean.within.groups` can be used to control data imputation. If it is set to TRUE, imputation will be done, otherwise missing values will be left in the data. For better view of amount of missing values in the data, the information about number and percentage of missing values is displayed automatically:  

```{r cache=FALSE}
# Without imputation:
data.CtF.ready <- make_Ct_ready(data = data.CtF,
                                imput.by.mean.within.groups = FALSE)
# A part of the data with missing values:
as.data.frame(data.CtF.ready)[19:25,]

# With imputation:
data.CtF.ready <- make_Ct_ready(data = data.CtF,
                                imput.by.mean.within.groups = TRUE)
# Missing values were imputed:
as.data.frame(data.CtF.ready)[19:25,]
```

**NOTE:** The data imputation process can significantly influence data; therefore, no default value was set to `imput.by.mean.within.groups` parameter to force specification by user.  

In general, a majority of functions in `RQdeltaCT` package can deal with missing data; however, some used methods are sensitive to missing data, including VIF calculating in `find_ref_gene()` (see [Reference gene selection] section) and PCA analysis (see [PCA analysis] section).

**NOTE:** The `make_Ct_ready()` function should be used even if the collapsing of technical replicates and data imputation is not required, because this function also prepare data structure to fit to further functions.  

---

## Relative quantification: 2^-Ct^ method

This method is useful for testing genes for they suitability to be a endogenous control by investigating whether studied experimental condition significantly influences their expression (see [Introduction] section).  

In this method, raw Ct values are transformed using 2^-Ct^ formula, summarized by means in compared study conditions, and a ratio of means (fold change) is calculated for experimental condition. All These processes are carried out by two functions:   

* `exp_Ct_dCt()` - this function performs Ct data transformation using 2^-Ct^ formula. Before further processing, transformed Ct data should be subjected to quality control using functions and methods described in [Quality control and filtering of transformed Ct data] section.
* `RQ_exp_Ct_dCt()` - this function performs relative quantification by:  
  + calculation of means (returned in columns with "_mean" pattern) and standard deviations (returned in columns with "_sd" pattern) of transformed Ct values of analyzed genes in compared groups.
  + normality testing (Shapiro_Wilk test) of transformed Ct values of analyzed genes within compared groups and returned p values are stored in columns with "_norm_p" pattern.
  + calculation of fold change values for each gene by dividing mean of transformed Ct values in study group by mean of transformed Ct values in reference group. Fold change values are returned in "FCh" column.
  + statistical testing of differences in transformed Ct values between study group and reference group. Student's t test and Mann-Whitney U test are implemented and resulted statistics (in column with "_test_stat" pattern) and p values (in column with "_test_p" pattern) are returned.


The `RQ_exp_Ct_dCt()` function gives a choice if normality and statistical tests should be done (`do.tests` parameter). In the situations, where compared groups contain less than three samples (at least three samples are required to testing), `do.test` should be set to FALSE too avoid error. 

```{r cache=FALSE}
data.Ct.exp <- exp_Ct_dCt(data = data.CtF.ready)
library(coin)
RQ.Ct.exp <- RQ_exp_Ct_dCt(data = data.Ct.exp,
                           do.tests = TRUE,
                           group.study = "Disease",
                           group.ref = "Control")

# Obtained table can be sorted by, e.g. p values from Mann-Whitney U test:
head(as.data.frame(arrange(RQ.Ct.exp, MW_test_p)))
```
**NOTE:** Both used functions are also used to analyze transformed delta Ct data (see [Relative quantification: 2^-dCt^ method]).

---

## Reference gene selection

Ideally, the reference gene should have an identical expression level in all samples, but in many situations it is not possible to achieve, especially when biological replicates are analyzed. Therefore, differences between samples are allowed, but the variance should be as low as possible, and it is also recommend that Ct values would not be very low (below 15) or very high (above 30) [Kozera and Rapacz 2013](https://link.springer.com/article/10.1007/s13353-013-0173-x).   
The `RQdeltaCT` package include `find_ref_gene()` function that can be used to select best reference gene for normalization. This function calculates descriptive statistics such as minimum, maximum, standard deviation, and variance, as well as more advance parameters including colinearity coefficient VIF (separately for each group) and stability scores calculated using [NormFinder](https://www.moma.dk/software/normfinder) ([Article](https://aacrjournals.org/cancerres/article/64/15/5245/511517/Normalization-of-Real-Time-Quantitative-Reverse)) and [geNorm](https://genorm.cmgg.be/) ([Article](https://genomebiology.biomedcentral.com/articles/10.1186/gb-2002-3-7-research0034)) algorithms. Ct values are also presented on a line plot.  

VIF colinearity coefficient is calculated usig `car::vif()` function running on multiple linear regression models with all genes as predictory variables and a dummy response variable. NormFinder scores are computed using additional `RQdeltaCT::norm_finder()` function working on the code adapted from the original NormFinder code. For geNorm score, `geNorm()` function from `ctrlGene` package is used.

Due to different resistance to data characteristics, `norm_finder()` function allows to choose which of these algorithms should be done by setting `vif.score`, `norm.finder.score`, and `genorm.score` logical parameters:

* VIF score is the most sensitive: it could be calculate for only two groups of samples, missing data could interfere correlation results (e.g. warning "In cov2cor(v) : diag(.) had 0 or NA entries; non-finite result is doubtful" can appear), and in the case of perfect correlation between genes, error "Error in vif.default(model) : there are aliased coefficients in the model" will be displayed and process will stop (it could especially occur when a low number samples is analyzed). In such a situation, `vif.score` should be set to FALSE.
* NormFinder algorithm is calculated on data with missing values and more than three groups, but at least two samples must be in each group.
* geNorm is free of limitations above.

Created plot is displayed on the graphic device. Returned object is a lists that contain two elements: object with plot and table with results. In example below, 6 genes are tested for suitability to be a reference gene: 

```{r fig.dim=c(7.1,4), cache=FALSE}
library(car)
library(ctrlGene)
# Remember that number of colors in col parameter should be equal to number of tested genes:
ref <- find_ref_gene(data = data.CtF.ready,
                     groups = c("Disease","Control"),
                     candidates = c("Gene4", "Gene8","Gene10","Gene16","Gene17", "Gene18"),
                     col = c("#66c2a5", "#fc8d62","#6A6599", "#D62728", "#1F77B4", "black"),
                     angle = 60,
                     axis.text.size = 7,
                     vif.score = TRUE,
                     norm.finder.score = TRUE,
                     genorm.score = TRUE)
ref[[2]]
```
Among tested genes, Gene8, Gene16, Gene17, and Gene18 seems to have the best characteristics to be a reference gene (they have low variance, high VIF values, and low NormFinder and geNorm scores).

**NOTE:** Missing data can be present in data, but it could generate a warning: "diag(.) had 0 or NA entries; non-finite result is doubtful" returned from `vif()` function.  

---

## Relative quantification: 2^-dCt^ method

This method is used in studies where samples should be analyzed as individual data points, e.g. in analysis of biological replicates (e.g. comparison between patients and healthy controls). In this method, Ct values are normalized by endogenous control gene by subtracting Ct value of endogenous control in sample from Ct value of gene gene in the same sample. Obtained delta Ct (dCt) values are subsequently transformed using 2^-dCt^ formula, summarized by means in compared study groups, and a ratio of means (fold change) is calculated for a study group (see [Introduction] section).  

The whole processes can be done using three functions:   

* `delta_Ct` - this function calculates delta Ct (dCt) values by subtracting Ct values of reference gene from Ct values of gene gene across all samples.
* `exp_Ct_dCt()` - this function performs transformation of dCt data using 2^-dCt^ formula. Before further processing, transformed dCt data should be subjected to quality control using functions and methods described in [Quality control and filtering of transformed Ct data] section.  
* `RQ_exp_Ct_dCt()` - this function performs:  
  + calculation of means (returned in columns with "_mean" pattern) and standard deviations (returned in columns with "_sd" pattern) of transformed dCt values of analyzed genes in compared groups.
  + normality testing (Shapiro_Wilk test) of transformed dCt values of analyzed genes in compared groups and returned p values are stored in columns with "_norm_p" pattern.
  + calculation of fold change values for each gene by dividing mean of transformed dCt values in study group by mean of transformed dCt values in reference group. Fold change values are returned in "FCh" column.
  + statistical testing of differences in transformed Ct values between study group and reference group. Student's t test and Mann-Whitney U test are implemented and resulted statistics (in column with "_test_stat" pattern) and p values (in column with "_test_p" pattern) are returned. If compared groups contain less than three samples, normality and statistical tests are not possible to perform (`do.test` parameter should be set to FALSE too avoid error). 

```{r cache=FALSE}
data.dCt <- delta_Ct(data = data.CtF.ready,
                     ref = "Gene8")
data.dCt.exp <- exp_Ct_dCt(data = data.dCt)
library(coin)
RQ.dCt.exp <- RQ_exp_Ct_dCt(data = data.dCt.exp,
                            do.tests = TRUE,
                            group.study = "Disease",
                            group.ref = "Control")

# Obtained table can be sorted by, e.g. p values from Mann-Whitney U test:
head(as.data.frame(arrange(RQ.dCt.exp, MW_test_p)))
```

---

## Relative quantification: 2^-ddCt^ method

Similarly to 2^-dCt^ method, in 2^-ddCt^ method Ct values are normalized by endogenous control gene obtaining dCt values. Subsequently, dCt values are summarized by means in compared groups, and for each gene, obtained mean in control group is subtracted from mean in a study group, giving delta delta Ct (ddCt) value. Finally, ddCt values are transformed using 2^-ddCt^ formula to obtain fold change values. This method is recommended for analysis of technical replicates (see [Introduction] section).

The whole processes can be done using three functions:   

* `delta_Ct` - this function calculates delta Ct (dCt) values by subtracting Ct values of reference gene from Ct values of gene genes across all samples. Before further processing, obtained dCt data should be subjected to quality control using functions and methods described in [Quality control and filtering of transformed Ct data] section.
* `RQ_ddCt()` - this function performs:  
   + calculation of means (returned in columns with "_mean" pattern) and standard deviations (returned in columns with "_sd" pattern) of delta Ct values of analyzed genes in compared groups.
   + normality testing (Shapiro_Wilk test) of delta Ct values of analyzed genes in compared groups and returned p values are stored in columns with "_norm_p" pattern.
   + calculation of differences in mean delta Ct values of genes between compared groups, returned in "ddCt" column,
   + calculation of fold change values (returned in "FCh" column) for each gene by transforming ddCt values using 2^-ddCt^ formula.
   + statistical testing of differences between compared groups. Student's t test and Mann-Whitney U test are implemented and resulted statistics (in column with "_test_stat" pattern) and p values (in column with "_test_p" pattern) are returned. If compared groups contain less than three samples, normality and statistical tests are not possible to perform and `do.test` parameter should be set to FALSE too avoid error. 

```{r cache=FALSE}
data.dCt <- delta_Ct(data = data.CtF.ready,
                     ref = "Gene8")
library(coin)
RQ.ddCt <- RQ_ddCt(data = data.dCt,
                   group.study = "Disease",
                   group.ref = "Control",
                   do.tests = TRUE)

# Obtained table can be sorted by, e.g. p values from Mann-Whitney U test:
head(as.data.frame(arrange(RQ.ddCt, MW_test_p)))
```

---

## Quality control and filtering of transformed Ct data

Data intended to use for relative quantification should be subjected to quality control assessment. The main purpose is to identify outlier samples that could introduce bias into results. The `RQdeltaCT` package offers several functions which facilitate finding outlier samples in data by implementing distribution analysis (`control_boxplot_sample()` function), hierarchical clustering (`control_cluster_sample()` function) and principal component analysis PCA (`control_pca_sample()` function). However, corresponding functions for genes are also provided to evaluate similarities and differences between expression of analyzed genes (`control_boxplot_gene()`, `control_cluster_gene()` and `control_pca_gene()` functions).

Abovementioned data quality control functions are designed to be directly applied to data objects returned from `make_Ct_ready()`, `exp_Ct_dCt()` and `delta_Ct()` functions (see [The summary of standard workflow]).

#### Analysis of data distribution

One of the ways to gain insight into data distribution is drawing boxplot that show several statistics, such as median (labeled inside box), first and third quartiles (ranged by box), extreme point in interquartile range (ranged by whiskers), and more distant data as separated points. In the `RQdeltaCT` package, `control_boxplot_sample()` and `control_boxplot_gene()` functions are included to draw boxplots that present distribution of samples and genes, respectively.

These functions return objects with plot. Created plots are also displayed on the graphic device.

```{r fig.dim=c(7.1,6), cache=FALSE}
control_boxplot_sample <- control_boxplot_sample(data = data.dCt,
                                                 axis.text.size = 7)
```
```{r fig.dim=c(7.1,4)}
control_boxplot_gene <- control_boxplot_gene(data = data.dCt,
                                                 by.group = TRUE,
                                                 axis.text.size = 10)
```

**NOTE:** If missing values are present in data, they will be automatically removed and warning "Warning message:
Removed 29 rows containing non-finite values (`stat_boxplot()`)" will appear.


#### Hierarchical clustering

Hierarchical clustering is a convenient method to investigate similarities between variables. Hierarchical clustering of samples and genes can be done using `control_cluster_sample()` and `control_cluster_gene()` functions, respectively. These functions allow to draw dendrogram using various methods of distance calculation (e.g. euclidean, canberra) and agglomeration (e.g. complete, average, single). For more details, refer to the functions documentation.

```{r fig.dim=c(7.1,4), cache=FALSE}
control_cluster_sample(data = data.dCt,
                       method.dist = "euclidean",
                       method.clust = "average",
                       label.size = 0.6)
control_cluster_gene(data = data.dCt,
                     method.dist = "euclidean",
                     method.clust = "average",
                     label.size = 0.8)
```

Created plots are displayed on the graphic device.

**NOTE:** Minimum three samples or genes in data is required for clustering analysis.

#### PCA analysis

Principal component analysis (PCA) is a data exploratory method, which is commonly used to investigate similarities between variables based on first principal components that contain the most information about variance. In the `RQdeltaCT` package, `control_pca_sample()` and `control_pca_gene()` functions are developed to perform PCA analysis for samples and genes, respectively. These functions return objects with plot. Created plots are also displayed on the graphic device.

```{r fig.dim=c(5,5.5), fig.align='center', cache=FALSE}
control.pca.sample <- control_pca_sample(data = data.dCt,
                                         point.size = 3,
                                         label.size = 2.5,
                                         legend.position = "top")
```
```{r fig.dim=c(5,5), fig.align='center', cache=FALSE}
control.pca.gene <- control_pca_gene(data = data.dCt)
```

**NOTE:** PCA algorithm can not deal with missing data (NAs); therefore, variables with NA values are removed before analysis. If at least one NA value occur in all variables in at least one of compared group, the analysis can not be done. Imputation of missing data will avoid this issue. Also, minimum three samples or genes in data is required for clustering analysis.

---

#### Data filtering after quality control

If any sample or gene was decided to be removed from data, `filter_transformed_data()` can be used to filtering. Similarly to quality control functions, this function can be directly applied to data objects returned from `make_Ct_ready()`, `exp_Ct_dCt()` and `delta_Ct()` functions (see [The summary of standard workflow]). 

```{r cache=FALSE}
data.dCtF <- filter_transformed_data(data = data.dCt,
                                     remove.Sample = c("Control11"))
```

---

## Final visualisations

For visualisation of final results, three functions can be used:

* `RQ_plot()` that allow to illustrate fold change values of genes,
* `results_barplot` that show mean and standard deviation values of genes across compared groups,
* `results_boxplot()` that illustrate data distribution of genes across compared groups.  

All these functions can be run on all data or on finally selected genes (see `sel.Gene` parameter), and also allow to add customized statistical significance labels to plots using `ggsignif` package. These functions have a large number of parameters, and user should familiarize with all of them to properly adjust created plots to user needs.

**NOTE:** If statistical significance labels should be added to the plot, a vector with labels (e.g. "ns", "*", "p = 0.03") should be provided in `signif.labels` parameter. There are two important matter that must be taking into account when preparing this vector:

* The order of labels should correspond to the order of genes presented on the plot, not the order of genes in the data, which can be different.
* In this vector, due to restrictions of `ggsignif` package, all values must be different (the same values are not allowed). Thus, if there is a need to use the same labels, they should made distinguishable by adding symmetrically different number of white spaces, e.g. "ns.", " ns. ", "  ns.  ", "   ns.   ", etc (see examples below). 

#### The `RQ_plot()` function

This function creates barplot illustrating fold change values obtained from the analysis, together with indication of statistical significance. Data returned from `RQ_exp_Ct_dCt()` and `RQ_ddCt()` functions can be directly applied to this function (see [The summary of standard workflow]).  

On the barplot, bars of significant genes are distinguished by colors and/or significance labels. Significance of genes can be set by two criteria: p values and (optionally) fold change values. Thresholds for both criteria can be specified. The `RQ_plot()` function offers various options of which p values are used on the plot:

* p values from Student's t test (if `mode` = "t").
* p values from Mann-Whitney U test (if `mode` = "mw").
* p values depend on normality of data (if `mode` = "depends"). If data in both compared groups were considered as derived from normal distribution (p value from Shapiro_Wilk test > 0.05) - p values from Student's t test will be used, otherwise p values from Mann-Whitney U test will be used.
* external p values provided by user (if `mode` = "user"). If user intends to use p values obtained from other statistical test, `mode` parameter should be set to "user". In this scenario, before run `RQ_plot()` function, user should prepare
a data.frame object named "user" containing two columns: the first column with gene names and the second column with p values (see example below).

Created plots are displayed on the graphic device. Returned objects are a lists that contain two elements: object with plot and table with results. 

```{r fig.dim=c(7.1,4), cache=FALSE}
# Variant with p values depending on data normality:
library(ggsignif)
# Specifying vector with significance labels: 
signif.labels <- c("****","**","ns."," ns. ","  ns.  ","   ns.   ","    ns.    ","     ns.     ","      ns.      ","       ns.       ","        ns.        ","         ns.         ","          ns.          ","           ns.           ","***")
# Genes with p < 0.05 and 2-fold changed expression between compared groups are considered as significant: 
RQ.plot <- RQ_plot(data = RQ.ddCt,
                   use.p = TRUE,
                   mode = "depends",
                   p.threshold = 0.05,
                   use.log10FCh = TRUE,
                   log10FCh.threshold = 0.30103,
                   signif.show = TRUE,
                   signif.labels = signif.labels,
                   angle = 20)
# Access table with results:
head(as.data.frame(RQ.plot[[2]]))
```

```{r fig.dim=c(7.1,4), cache=FALSE}
# Variant with user p values - used p values are calculated using stats::wilcox.test() function:
user <- data.dCt %>%
          pivot_longer(cols = -c(Group, Sample),
                       names_to = "Gene",
                       values_to = "dCt") %>%
          group_by(Gene) %>%
          summarise(MW_test_p = wilcox.test(dCt ~ Group)$p.value,
                    .groups = "keep")
# The stats::wilcox.test() functions is limited to cases without ties; therefore, a warning "cannot compute exact p-value with ties" will appear when ties occurr.

RQ.plot <- RQ_plot(data = RQ.ddCt,
                   use.p = TRUE,
                   mode = "user",
                   p.threshold = 0.05,
                   use.log10FCh = TRUE,
                   log10FCh.threshold = 0.30103,
                   signif.show = TRUE,
                   signif.labels = signif.labels,
                   angle = 30)
# Access table with results:
head(as.data.frame(RQ.plot[[2]]))
```

Three genes (Gene1, Gene12, and Gene19) are showed to met used significance criteria.

**NOTE:** If p values were not calculated due to low number of samples, or they are not intended to be used to create plot, `use.p` parameter should be set to FALSE.

#### The `results_boxplot()` function

This function creates a boxplot illustrating distribution of data for genes. It is similar to `control_boxplot_gene()` function; however, some new options are added, including gene selection, faceting, addition of mean points to boxes, and statistical significance labels.

Data objects returned from `make_Ct_ready()`, `exp_Ct_dCt()` and `delta_Ct() functions` can be directly applied to this function (see [The summary of standard workflow]).

```{r fig.dim=c(5,4.5), fig.align='center', cache=FALSE}
final_boxplot <- results_boxplot(data = data.dCtF,
                                 sel.Gene = c("Gene1","Gene12", "Gene16","Gene19"),
                                 by.group = TRUE,
                                 signif.show = TRUE,
                                 signif.labels = c("****","*","***"," * "),
                                 signif.dist = 1.05,
                                 faceting = TRUE,
                                 facet.row = 1,
                                 facet.col = 4,
                                 y.exp.up = 0.1,
                                 angle = 20,
                                 y.axis.title = "dCt")
```

**NOTE:** If missing values are present in data, they will be automatically removed and warning will appear.

#### The `results_barplot()` function

This function creates a barplot illustrating mean and standard deviation values of data for all or selected genes.

Data objects returned from `make_Ct_ready()`, `exp_Ct_dCt()` and `delta_Ct() functions` can be directly applied to this function (see [The summary of standard workflow]).

```{r fig.dim=c(5,4.5), fig.align='center', cache=FALSE}
final_barplot <- results_barplot(data = data.dCtF,
                                 sel.Gene = c("Gene1","Gene12","Gene19","Gene20"),
                                 signif.show = TRUE,
                                 signif.labels = c("****","*","***"," * "),
                                 angle = 30,
                                 signif.dist = 1.05,
                                 faceting = TRUE,
                                 facet.row = 1,
                                 facet.col = 4,
                                 y.exp.up = 0.1,
                                 y.axis.title = "dCt")
```

**NOTE:** A minimum two samples in each group are required to calculate standard deviation and properly generate plot.

---

## Further analyses

Expression levels of genes and differences between groups can be further analysed using the following methods and corresponding functions from the `RQdeltaCT` package:

* correlation analysis - used to generating and visualisation of correlation matrix of samples (`corr_sample()` function) and genes (`corr_gene()` function).
* simple linear regression - used to analysis and visualisation of relationships between pair of samples (`single_pair_sample()` function) and genes (`single_pair_gene()` function).
* Receiver Operating Characteristic (ROC) analysis - used to evaluation of performance of sample classification by gene expression data (`ROCh()` function).
* simple logistic regression analysis - used to calculation odds ratio values for genes (`log_reg()` function).  

Data objects returned from `make_Ct_ready()`, `exp_Ct_dCt()` and `delta_Ct() functions` can be directly applied to all of these functions (see [The summary of standard workflow]). Moreover, all functions can be run on the entire data or only on selected samples/genes.

#### Correlation analysis

Correlation analysis is a very useful method to explore linear relationships between variables. The `RQdeltaCT` package offers `corr_sample()` and `corr_gene()` functions to generate and plot correlation matrices of samples and genes, respectively. Correlation coefficients can be calculated using either Pearson or Spearman algorithm. To facilitate plots interpretation, these functions have also possibilities to order samples or genes according to several methods, e.g. hierarchical clustering or PCA first component (see `order` parameter).

```{r fig.dim=c(6.5,6.5), fig.align='center', cache=FALSE}
library(Hmisc)
library(corrplot)
# To make the plot to be more readable, only part of data was used:
corr.samples <- corr_sample(data = data.dCtF[15:30, ],
                            method = "pearson",
                            order = "hclust",
                            size = 0.7,
                            p.adjust.method = "BH")
```
```{r fig.dim=c(6.5,6.5), fig.align='center', cache=FALSE}
library(Hmisc)
library(corrplot)
corr.genes <- corr_gene(data = data.dCt,
                            method = "spearman",
                            order = "FPC",
                            size = 0.7,
                            p.adjust.method = "BH")
```

Created plots are displayed on the graphic device. Returned objects are a tables with computed correlation coefficients, p values and p values adjusted by Benjamini-Hochberg correction (by default). Tables are sorted by descending absolute values of correlation coefficients.

**NOTE:** A minimum 5 samples/target are required for correlation analysis.

#### Simple linear regression analysis

Linear relationships between pairs of samples or genes can be further analysed using simple linear regression models using `single_pair_sample()` function (for analysis of samples) and `single_pair_gene()` function for analysis of genes. These functions draw a scatter plot with simple linear regression line. Regression results such as regression equation, coefficient of determination, F value, or p value can be optionally add to plot. 

```{r fig.dim=c(4.5,4.5), fig.align='center', cache=FALSE}
library(ggpmisc)
Disease6_Control17 <- single_pair_sample(data = data.dCt,
                                         x = "Disease6",
                                         y = "Control17",
                                         point.size = 3,
                                         labels = TRUE,
                                         label = c("eq", "R2", "p"),
                                         label.position.x = 0.05)
```
```{r fig.dim=c(5,4.5), fig.align='center', cache=FALSE}
library(ggpmisc)
Gene16_Gene17 <- single_pair_gene(data.dCt,
                                    x = "Gene16",
                                    y = "Gene17",
                                    by.group = TRUE,
                                    point.size = 3,
                                    labels = TRUE,
                                    label = c("eq", "R2", "p"),
                                    label.position.x = c(0.05),
                                    label.position.y = c(1,0.95))
```

#### Receiver Operating Characteristic (ROC) analysis

Receiver Operating Characteristic (ROC) analysis is useful to assess the performance of sample classification to paricular group, based on gene expression data. In this analysis, ROC curves together with such parameters as area under curve (AUC), specificity, sensitivity, accuracy, positive and negative predictive value are received. The `ROCh()` function was designed to perform all of these tasks. This function returns table with calculated parameters and plot with multiple panels, each with ROC curve for one gene.  

**NOTE:** Created plot is not displayed on graphic device, as usually, but should be saved as .tiff image (`save.to.txt` = TRUE) and opened directly from file in working directory.

```{r cache=FALSE}
library(pROC)
# Remember to specify numbers of rows (panels.row parameter) and columns (panels.col parameter) to be sufficient to arrange panels of all analyzed genes: 
roc_parameters <- ROCh(data = data.dCt,
                       sel.Gene = c("Gene1","Gene12","Gene16","Gene19"),
                       groups = c("Disease","Control"),
                       panels.row = 2,
                       panels.col = 2)
roc_parameters
```

```{r echo=FALSE, out.width="500px", fig.align="center", warning=FALSE, message=FALSE, cache=FALSE}
library(here)
knitr::include_graphics(file.path(here::here(),"vignettes", "figure", "ROC_plot.png"))

```

#### Simple logistic regression

Logistic regression is useful method to investigate impact of analyzed variable on the odds of the occurrence of the studied experimental condition. In the `RQdeltaCT` package, `log_reg()` function allows to calculate for each gene a chances (odds ratio, OR) of being included in the study group when gene expression level increases by one unit. This function returns plot and table with calculated parameters (OR, confidence interval, intercept, coefficient, and p values).

```{r fig.dim=c(5,4), fig.align='center', cache=FALSE}
library(oddsratio)
log.reg.results <- log_reg(data = data.dCt,
                           sel.Gene = c("Gene1","Gene12","Gene16","Gene19"),
                           group.study = "Disease",
                           group.ref = "Control")
log.reg.results[[2]]
```
#### Session info
```{r}
sessionInfo()
```
